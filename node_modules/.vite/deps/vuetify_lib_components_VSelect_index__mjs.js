import {
  VTextField,
  makeVTextFieldProps
} from "./chunk-OXXZRYF4.js";
import {
  VCheckboxBtn
} from "./chunk-ATP6M2BO.js";
import {
  VChip
} from "./chunk-HJWYAFBR.js";
import "./chunk-GVPNCO7B.js";
import "./chunk-W3RGKZN4.js";
import {
  useForm
} from "./chunk-NQLU3HST.js";
import {
  VMenuSymbol,
  VOverlay,
  makeVOverlayProps,
  useScopeId
} from "./chunk-SBVOEYBN.js";
import {
  forwardRefs
} from "./chunk-VKSCDZAW.js";
import {
  VList,
  VListItem,
  makeItemsProps,
  useItems
} from "./chunk-3U6SJNA3.js";
import "./chunk-FOTFCGPI.js";
import "./chunk-MKXCI4BO.js";
import "./chunk-WGICJAIF.js";
import "./chunk-TBHTBIJS.js";
import "./chunk-BZ3WF4IW.js";
import "./chunk-S6WIUGW7.js";
import "./chunk-VKABKQAG.js";
import "./chunk-J3IE3YXH.js";
import "./chunk-4VFORJTP.js";
import "./chunk-UZRNUR5Q.js";
import "./chunk-WAHNJOZU.js";
import {
  VDialogTransition
} from "./chunk-W3INCKUW.js";
import "./chunk-DGEONA6R.js";
import {
  VDefaultsProvider
} from "./chunk-WZ7PHQK4.js";
import "./chunk-ZHCUH3VH.js";
import "./chunk-GMODCS3U.js";
import {
  makeTransitionProps
} from "./chunk-WPFOBS7S.js";
import "./chunk-PZI3Q7R6.js";
import {
  useLocale
} from "./chunk-7DA2GDLV.js";
import {
  useProxiedModel
} from "./chunk-7YDSNCRX.js";
import "./chunk-WUBZZSJC.js";
import "./chunk-RGJCMEQN.js";
import "./chunk-3HUHM66Q.js";
import {
  IconValue
} from "./chunk-KM4OLWNA.js";
import "./chunk-RHNSNUFE.js";
import {
  deepEqual,
  genericComponent,
  getUid,
  omit,
  propsFactory,
  useRender,
  wrapInArray
} from "./chunk-TNAZMCT5.js";
import {
  Fragment,
  computed,
  createTextVNode,
  createVNode,
  inject,
  mergeProps,
  provide,
  ref,
  watch
} from "./chunk-SE5EWVSA.js";
import "./chunk-S5KM4IGW.js";

// node_modules/vuetify/lib/components/VSelect/VSelect.mjs
import "/Users/zikangying/Desktop/Learning/AWS/my-event-planner/node_modules/vuetify/lib/components/VSelect/VSelect.css";

// node_modules/vuetify/lib/components/VMenu/VMenu.mjs
import "/Users/zikangying/Desktop/Learning/AWS/my-event-planner/node_modules/vuetify/lib/components/VMenu/VMenu.css";
var VMenu = genericComponent()({
  name: "VMenu",
  props: {
    id: String,
    ...omit(makeVOverlayProps({
      closeDelay: 250,
      closeOnContentClick: true,
      locationStrategy: "connected",
      openDelay: 300,
      scrim: false,
      scrollStrategy: "reposition",
      transition: {
        component: VDialogTransition
      }
    }), ["absolute"])
  },
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const isActive = useProxiedModel(props, "modelValue");
    const {
      scopeId
    } = useScopeId();
    const uid = getUid();
    const id = computed(() => props.id || `v-menu-${uid}`);
    const overlay = ref();
    const parent = inject(VMenuSymbol, null);
    const openChildren = ref(0);
    provide(VMenuSymbol, {
      register() {
        ++openChildren.value;
      },
      unregister() {
        --openChildren.value;
      },
      closeParents() {
        setTimeout(() => {
          if (!openChildren.value) {
            isActive.value = false;
            parent == null ? void 0 : parent.closeParents();
          }
        }, 40);
      }
    });
    watch(isActive, (val) => {
      val ? parent == null ? void 0 : parent.register() : parent == null ? void 0 : parent.unregister();
    });
    function onClickOutside() {
      parent == null ? void 0 : parent.closeParents();
    }
    const activatorProps = computed(() => mergeProps({
      "aria-haspopup": "menu",
      "aria-expanded": String(isActive.value),
      "aria-owns": id.value
    }, props.activatorProps));
    useRender(() => {
      const [overlayProps] = VOverlay.filterProps(props);
      return createVNode(VOverlay, mergeProps({
        "ref": overlay,
        "class": ["v-menu"]
      }, overlayProps, {
        "modelValue": isActive.value,
        "onUpdate:modelValue": ($event) => isActive.value = $event,
        "absolute": true,
        "activatorProps": activatorProps.value,
        "onClick:outside": onClickOutside
      }, scopeId), {
        activator: slots.activator,
        default: function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return createVNode(VDefaultsProvider, {
            "root": true
          }, {
            default: () => {
              var _a;
              return [(_a = slots.default) == null ? void 0 : _a.call(slots, ...args)];
            }
          });
        }
      });
    });
    return forwardRefs({
      id,
      \u03A8openChildren: openChildren
    }, overlay);
  }
});

// node_modules/vuetify/lib/components/VSelect/VSelect.mjs
var makeSelectProps = propsFactory({
  chips: Boolean,
  closableChips: Boolean,
  eager: Boolean,
  hideNoData: Boolean,
  hideSelected: Boolean,
  menu: Boolean,
  menuIcon: {
    type: IconValue,
    default: "$dropdown"
  },
  menuProps: {
    type: Object
  },
  multiple: Boolean,
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  openOnClear: Boolean,
  valueComparator: {
    type: Function,
    default: deepEqual
  },
  ...makeItemsProps({
    itemChildren: false
  })
}, "v-select");
var VSelect = genericComponent()({
  name: "VSelect",
  props: {
    ...makeSelectProps(),
    ...omit(makeVTextFieldProps({
      modelValue: null
    }), ["validationValue", "dirty", "appendInnerIcon"]),
    ...makeTransitionProps({
      transition: {
        component: VDialogTransition
      }
    })
  },
  emits: {
    "update:modelValue": (val) => true,
    "update:menu": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const vTextFieldRef = ref();
    const vMenuRef = ref();
    const _menu = useProxiedModel(props, "menu");
    const menu = computed({
      get: () => _menu.value,
      set: (v) => {
        var _a;
        if (_menu.value && !v && ((_a = vMenuRef.value) == null ? void 0 : _a.\u03A8openChildren))
          return;
        _menu.value = v;
      }
    });
    const {
      items,
      transformIn,
      transformOut
    } = useItems(props);
    const model = useProxiedModel(props, "modelValue", [], (v) => transformIn(wrapInArray(v)), (v) => {
      var _a;
      const transformed = transformOut(v);
      return props.multiple ? transformed : (_a = transformed[0]) != null ? _a : null;
    });
    const form = useForm();
    const selections = computed(() => {
      return model.value.map((v) => {
        return items.value.find((item) => props.valueComparator(item.value, v.value)) || v;
      });
    });
    const selected = computed(() => selections.value.map((selection) => selection.props.value));
    const displayItems = computed(() => {
      if (props.hideSelected) {
        return items.value.filter((item) => !selections.value.some((s) => s === item));
      }
      return items.value;
    });
    const listRef = ref();
    function onClear(e) {
      if (props.openOnClear) {
        menu.value = true;
      }
    }
    function onMousedownControl() {
      if (props.hideNoData && !items.value.length || props.readonly || (form == null ? void 0 : form.isReadonly.value))
        return;
      menu.value = !menu.value;
    }
    function onKeydown(e) {
      var _a, _b, _c, _d;
      if (props.readonly || (form == null ? void 0 : form.isReadonly.value))
        return;
      if (["Enter", " ", "ArrowDown", "ArrowUp", "Home", "End"].includes(e.key)) {
        e.preventDefault();
      }
      if (["Enter", "ArrowDown", " "].includes(e.key)) {
        menu.value = true;
      }
      if (["Escape", "Tab"].includes(e.key)) {
        menu.value = false;
      }
      if (e.key === "ArrowDown") {
        (_a = listRef.value) == null ? void 0 : _a.focus("next");
      } else if (e.key === "ArrowUp") {
        (_b = listRef.value) == null ? void 0 : _b.focus("prev");
      } else if (e.key === "Home") {
        (_c = listRef.value) == null ? void 0 : _c.focus("first");
      } else if (e.key === "End") {
        (_d = listRef.value) == null ? void 0 : _d.focus("last");
      }
    }
    function select(item) {
      if (props.multiple) {
        const index = selected.value.findIndex((selection) => props.valueComparator(selection, item.value));
        if (index === -1) {
          model.value = [...model.value, item];
        } else {
          const value = [...model.value];
          value.splice(index, 1);
          model.value = value;
        }
      } else {
        model.value = [item];
        menu.value = false;
      }
    }
    function onBlur(e) {
      var _a;
      if (!((_a = listRef.value) == null ? void 0 : _a.$el.contains(e.relatedTarget))) {
        menu.value = false;
      }
    }
    function onFocusout(e) {
      var _a;
      if (e.relatedTarget == null) {
        (_a = vTextFieldRef.value) == null ? void 0 : _a.focus();
      }
    }
    useRender(() => {
      const hasChips = !!(props.chips || slots.chip);
      const hasList = !!(!props.hideNoData || displayItems.value.length || slots.prepend || slots.append || slots["no-data"]);
      const [textFieldProps] = VTextField.filterProps(props);
      return createVNode(VTextField, mergeProps({
        "ref": vTextFieldRef
      }, textFieldProps, {
        "modelValue": model.value.map((v) => v.props.value).join(", "),
        "onUpdate:modelValue": (v) => {
          if (v == null)
            model.value = [];
        },
        "validationValue": model.externalValue,
        "dirty": model.value.length > 0,
        "class": ["v-select", {
          "v-select--active-menu": menu.value,
          "v-select--chips": !!props.chips,
          [`v-select--${props.multiple ? "multiple" : "single"}`]: true,
          "v-select--selected": model.value.length
        }],
        "appendInnerIcon": props.menuIcon,
        "readonly": true,
        "onClick:clear": onClear,
        "onMousedown:control": onMousedownControl,
        "onBlur": onBlur,
        "onKeydown": onKeydown
      }), {
        ...slots,
        default: () => createVNode(Fragment, null, [createVNode(VMenu, mergeProps({
          "ref": vMenuRef,
          "modelValue": menu.value,
          "onUpdate:modelValue": ($event) => menu.value = $event,
          "activator": "parent",
          "contentClass": "v-select__content",
          "eager": props.eager,
          "maxHeight": 310,
          "openOnClick": false,
          "closeOnContentClick": false,
          "transition": props.transition
        }, props.menuProps), {
          default: () => [hasList && createVNode(VList, {
            "ref": listRef,
            "selected": selected.value,
            "selectStrategy": props.multiple ? "independent" : "single-independent",
            "onMousedown": (e) => e.preventDefault(),
            "onFocusout": onFocusout
          }, {
            default: () => {
              var _a, _b, _c, _d;
              return [!displayItems.value.length && !props.hideNoData && ((_b = (_a = slots["no-data"]) == null ? void 0 : _a.call(slots)) != null ? _b : createVNode(VListItem, {
                "title": t(props.noDataText)
              }, null)), (_c = slots["prepend-item"]) == null ? void 0 : _c.call(slots), displayItems.value.map((item, index) => {
                var _a2;
                if (slots.item) {
                  return (_a2 = slots.item) == null ? void 0 : _a2.call(slots, {
                    item,
                    index,
                    props: mergeProps(item.props, {
                      onClick: () => select(item)
                    })
                  });
                }
                return createVNode(VListItem, mergeProps({
                  "key": index
                }, item.props, {
                  "onClick": () => select(item)
                }), {
                  prepend: (_ref2) => {
                    let {
                      isSelected
                    } = _ref2;
                    return props.multiple && !props.hideSelected ? createVNode(VCheckboxBtn, {
                      "modelValue": isSelected,
                      "ripple": false
                    }, null) : void 0;
                  }
                });
              }), (_d = slots["append-item"]) == null ? void 0 : _d.call(slots)];
            }
          })]
        }), selections.value.map((item, index) => {
          var _a, _b;
          function onChipClose(e) {
            e.stopPropagation();
            e.preventDefault();
            select(item);
          }
          const slotProps = {
            "onClick:close": onChipClose,
            modelValue: true,
            "onUpdate:modelValue": void 0
          };
          return createVNode("div", {
            "key": item.value,
            "class": "v-select__selection"
          }, [hasChips ? !slots.chip ? createVNode(VChip, mergeProps({
            "key": "chip",
            "closable": props.closableChips,
            "size": "small",
            "text": item.title
          }, slotProps), null) : createVNode(VDefaultsProvider, {
            "key": "chip-defaults",
            "defaults": {
              VChip: {
                closable: props.closableChips,
                size: "small",
                text: item.title
              }
            }
          }, {
            default: () => {
              var _a2;
              return [(_a2 = slots.chip) == null ? void 0 : _a2.call(slots, {
                item,
                index,
                props: slotProps
              })];
            }
          }) : (_b = (_a = slots.selection) == null ? void 0 : _a.call(slots, {
            item,
            index
          })) != null ? _b : createVNode("span", {
            "class": "v-select__selection-text"
          }, [item.title, props.multiple && index < selections.value.length - 1 && createVNode("span", {
            "class": "v-select__selection-comma"
          }, [createTextVNode(",")])])]);
        })])
      });
    });
    return forwardRefs({
      menu,
      select
    }, vTextFieldRef);
  }
});
export {
  VSelect
};
//# sourceMappingURL=vuetify_lib_components_VSelect_index__mjs.js.map
